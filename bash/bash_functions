# ~/.bash_functions ‚Äî funciones √∫tiles no cubiertas por aliases

# Comprueba binarios requeridos antes de ejecutar la funci√≥n
_req(){
  for cmd in "$@"; do 
    if ! command -v "$cmd" >/dev/null 2>&1; then
      printf 'Error: necesito "%s" en $PATH.\n' "$cmd" >&2
      return 1
    fi
  done
}

# Abre $1 con $EDITOR posicionado en la linea $2 (si existe soporte tipo nvim +NUM)
_edit_at() {
  local file="$1" line="$2"
  local editor="${EDITOR:-nvim}"

  if [ -n "$line" ]; then
    "$editor" "+${line}" -- "$file"
  else
    "$editor" -- "$file"
  fi
}

# Buscar archivo/directorio y abrir
# - Maneja espacios en nombres
# - No peta si no eliges nada
# - Si seleccionas un directorio, te pregunta si quieres cd o abrir en el editor

fo() {
  _req fd fzf bat eza || return 1

  local sel
  sel="$(
    fd --hidden --follow --color=never --exclude .git \
    | fzf   --ansi \
            --prompt ' abrir > ' \
            --preview='
                  if [ -d {} ]; then
                      eza -la --color=always {}
                  else
                      bat --style=numbers --color=always {} 2>/dev/null | head -500
                  fi
            ' \
            --preview-window=right,70%
  )" || return 0

  [ -z "$sel" ] && return 0

  if [ -d "$sel" ]; then
    printf 'Has elegido un directorio: %s\n' "$sel" >&2
    printf '¬øEntrar con "cd" (c) o abrir en editor (e)? [c/e] ' >&2
    read -r ans 
    if [ "$ans" = "c" ]; then
      cd -- "$sel" || printf 'No pude hacer cd.\n' >&2
      return
    fi
    "${EDITOR:-nvim}" -- "$sel"
  else
    "${EDITOR:-nvim}" -- "$sel"
  fi

}


# Saltar a un directorio reciente/zoxide 
# - Verifica zoxide
# - Evita hacer cd a rutas que ya no existen
# - Maneja rutas con espacios
cdf() {
  _req zoxide fzf eza || return 1

  local dir 
  dir="$(
      zoxide query -l \
      | sed '/^$/d' \
      | sort -u \
      | fzf   --ansi \
              --prompt ' cd > ' \
              --preview 'eza -la --color=always {}' \
              --preview-window=right,60%
  )" || return 0

  [ -z "$dir" ] && return 0

  if [ ! -d "$dir" ]; then
    printf 'Ruta elegida ya no existe: %s\n' "$dir" >&2
    return 1
  fi

  cd -- "$dir" || printf 'No pude hacer cd.\n' >&2
}

# Checkout de rama con preview del hist√≥rico
# - Comprueba que est√°s en un repo git.
# - Incluye rama actual destacada
# - Evita fallo si no eliges nada

gcof() {
  _req git fzf || return 1

  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    printf 'Aqu√≠ no hay repo git.\n' >&2
    return 1
  fi

  local current
  current="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)"

  local branch
  branch="$(
      git for-each-ref --format='%(refname:short)' refs/heads \
      | sed '/^$/d' \
      | fzf   --ansi \
              --prompt=' branch > ' \
              --header="Actual: ${current}" \
              --preview='git log --oneline --decorate --graph -n 30 {}' \
              --preview-window=right,70%
  )" || return 0

  [ -z "$branch" ] && return 0

  git checkout -- "$branch"
}

# Matar procesos con confirmaci√≥n
# - No mata ciegamente con -9
# - Evita matar PID 1, tu propio shell
# - Envia SIGTERM primero, luego opcional SIGKILL
# - Pide confirmaci√≥n

fkill() {
  _req fzf ps awk kill || return 1

  local sel
  sel="$(
      ps -eo pid,user,stat,%cpu,%mem,cmd --sort=-%cpu \
      | awk 'NR>1' \
      | fzf   --ansi --multi \
              --prompt=' kill > ' \
              --header='Selecciona procesos a terminar (SPACE para marcar, ENTER para confirmar)' \
              --preview='echo PID:{1}; ps -p {1} -o pid,ppid,user,stat,%cpu,%mem,etime,cmd' \
              --preview-window=down,50%
  )" || return 0

  [ -z "$sel" ] && return 0

  local pids=()
  local line pid
  while IFS= read -r line; do
    pid="$(printf '%s\n' "$line" | awk '{print $1}')"
    if [ "$pid" = "1" ] || [ "$pid" = "$$" ]; then
      continue
    fi
    pids+=("$pid")
  done <<< "$sel"

  [ "${#pids[@]}" -eq 0 ] && {
      printf 'Nada que matar.\n' >&2
      return 0
  }

  printf 'Vas a enviar SIGTERM a: %s\n' "${pids[*]}" >&2
  printf '¬øContinuar? [y/N] ' >&2
  read -r ans
  [ "$ans" = "y" ] || return 0

  kill -- "${pids[@]}" 2>/dev/null

  sleep 0.3
  local still_up=()
  for pid in "${pids[@]}"; do
    if kill -0 "$pid" 2>/dev/null; then
      still_up+=("$pid")
    fi
  done

  if [ "${#still_up[@]}" -gt 0 ]; then
    printf 'Estos siguen vivos: %s\n' "${still_up[*]}" >&2
    printf '¬øForzar con SIGKILL (-9)? [y/N] ' >&2
    read -r force
    [ "$force" = "y" ] && kill -9 -- "${still_up[@]}" 2>/dev/null
  fi
}


# Buscar en el repo con ripgrep + abrir en el editor
# - Maneja patr√≥n vacio
# - Soporta m√∫ltiples selecciones
# - Respeta espacios en rutas.
# - Abre el editor saltando a la linea exacta
# - Vista previa recortada centrada en la linea del match

rgf(){
  _req rg fzf bat || return 1

  if [ $# -eq 0 ]; then
    printf 'Uso: rgf <patr√≥n de b√∫squeda>\n' >&2
    return 1
  fi

  local results
  results="$(
      rg --hidden --glob '!.git' --line-number --no-heading --color=never -- "$@" \
      | fzf   --multi \
              --prompt=' rg > ' \
              --delimiter=':' \
              --nth=3.. \
              --preview='
                    line={2}
                    start=$(( line - 10 ))
                    [ "$start" -lt 1 ] && start=1
                    end=$(( line + 30 ))

                    bat --style=numbers --color=always \
                        --highlight-line "$line" \
                        --line-range "${start}:${end}" \
                        {1} 2>/dev/null
              ' \
              --preview-window=right,70%
  )" || return 0

  [ -z "$results" ] && return 0

  local sel fpath lnum
  while IFS= read -r sel; do
    fpath="$(printf '%s\n' "$sel" | awk -F: '{print $1}')"
    lnum="$(printf '%s\n' "$sel" | awk -F: '{print $2}')"

    [ -n "$fpath" ] && [ -f "$fpath" ] && _edit_at "$fpath" "$lnum"
  done <<< "$results"
}


# mkdir + cd
take() {
  if [ -z "$1" ]; then
    printf "Uso: take <directorio>" >&2
    return 1
  fi
  mkdir -p -- "$1" && cd -- "$1" || return
}

# Extraer archivos comprimidos con una sola orden
extract() {
  if [ -z "$1" ] || [ ! -f "$1" ]; then
    printf "Uso: extract <archivo>" >&2
    return 1
  fi
  case "$1" in
    *.tar.bz2)   tar xjf "$1"   ;;
    *.tar.gz)    tar xzf "$1"   ;;
    *.tar.xz)    tar xJf "$1"   ;;
    *.tar)       tar xf  "$1"   ;;
    *.tbz2)      tar xjf "$1"   ;;
    *.tgz)       tar xzf "$1"   ;;
    *.bz2)       bunzip2 "$1"   ;;
    *.gz)        gunzip  "$1"   ;;
    *.xz)        unxz    "$1"   ;;
    *.zip)       unzip   "$1"   ;;
    *.7z)        7z x    "$1"   ;;
    *)           printf "'%s' no es un formato soportado\n" "$1" >&2; return 2 ;;
  esac
}

# Lanzar/adjuntar a una sesi√≥n tmux por nombre (default: main)
t() {
  local name="${1:-main}"
  tmux new -A -s "$name"
}

# Copiar salida de un comando al clipboard del sistema (Wayland/X11)
# - Soporta pipe ("echo foo | cb") y argumento ("cb foo")
cb() {
  local input
  if [ -t 0 ]; then
    input="$*"
    [ -z "$input" ] && { printf 'Uso: echo "texto" | cb   o   cb "texto"\n' >&2; return 1;}
  else
    input="$(cat)"
  fi

  if command -v wl-copy >/dev/null 2>&1; then
    printf '%s' "$input" | wl-copy
  elif command -v xclip >/dev/null 2>&1; then
    printf '%s' "$input" | xclip -selection clipboard
  else
    printf "No hay wl-copy ni xclip instalados\n" >&2
    return 1
  fi
}

# Buscar en el historial con fzf y (opcionalmente) ejecutar
# - Pide confirmaci√≥n ANTES de eval

fhist() {
    _req fzf || return 1

    local cmd
    cmd="$(
        HISTTIMEFORMAT= history \
        | sed 's/^ *[0-9]\+ *//' \
        | fzf --height 40% \
              --layout=reverse \
              --tac \
              --prompt='üìú hist > '
    )" || return 0

    [ -z "$cmd" ] && return 0

    printf 'Comando seleccionado:\n%s\n' "$cmd" >&2
    printf '¬øEjecutar ahora? [y/N] ' >&2
    read -r ans
    if [ "$ans" = "y" ]; then
        eval "$cmd"
    else
        printf '%s\n' "$cmd"
    fi
}

# Ir a la raiz del repo
grt() {
  _req git || return 1

  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    printf 'No estas en un repo git.\n' >&2
    return 1
  fi

  local root
  root="$(git rev-parse --show-toplevel 2>/dev/null)" || return 1
  builtin cd -- "$root" || {
    printf 'No puede hacer cd a %s\n' "$root" >&2
    return 1
  }
}

# Checkout r√°pido de rama (local o remota) con creaci√≥n autom√°tica
# - unifica "c√°mbiame a rama X" y "cr√©ame rama feature/X" en una sola acci√≥n
gbr() {
  _req git fzf || return 1

  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    printf 'Aqui no hay repo git.\n' >&2
    return 1
  fi

  local branch
  branch="$(
      {
          git for-each-ref --format='%(refname:short)' refs/heads
          git for-each-ref --format='%(refname:short)' refs/remotes \
            | sed 's#^origin/##'
      } \
      | sort -u \
      | fzf --prompt=' branch > ' --ansi \
            --preview='git log --oneline --decorate --graph -n 20 {}' \
            --preview-window=right,70%
  )" || return 0

  [ -z "$branch" ] && return 0

  if git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
    git checkout -b "$branch" "origin/$branch"
    return
  fi

  printf 'Rama "%s" no existe, crear desde HEAD actual? [y/N] ' "$branch" >&2
  read -r ans 
  [ "$ans" = "y" ] && git checkout -b "$branch"
}


# Que vamos a commitear realmente (diff staged bonito)
gstaged() {
  _req git bat || return 1

  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    printf 'No est√°s en un repo git.\n' >&2
    return 1
  fi

  git diff --cached --color=always \
  | bat --paging=always --plain --color=always
}

# Deshacer el √∫ltimo commit pero mantener los cambios en el working directory
# - soft reset seguro
gundo() {
  _req git || return 1
  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    printf 'No est√°s en un repo git.\n' >&2
    return 1
  fi

  printf 'Esto har√°: git reset --soft HEAD~1 (deshace el √∫ltimo commit pero conserva los cambios).\n' >&2
  printf '¬øContinuar? [y/N] ' >&2
  read -r ans 
  [ "$ans" = "y" ] || return 0

  git reset --soft HEAD~1
}

# Servicios docker actiovos (docker compose ps)
docps() {
  _req docker || return 1
  ( grt >/dev/null 2>&1 || true )
  if command -v docker-compose >/dev/null 2>&1; then
    docker-compose ps
  else
    docker compose ps
  fi
}

# fzf para elegir servicio y ver logs -f
dlogs() {
  _req fzf docker || return 1
  ( grt >/dev/null 2>&1 || true )

  local svc 
  svc="$(
      if command -v docker-compose >/dev/null 2>&1; then 
        docker-compose ps --services
      else
        docker compose ps --services
      fi | fzf --prompt=' logs > '
  )" || return 0

  [ -z "$svc" ] && return 0

  if command -v docker-compose >/dev/null 2>&1; then
    docker-compose logs -f "$svc"
  else
    docker compose logs -f "$svc"
  fi
}

# Entrar en un servicio con /bin/sh (o bash si existe)
dsh() {
  _req fzf docker || return 1
  ( grt >/dev/null 2>&1 || true )

  local svc 
  svc="$(
      if command -v docker-compose >/dev/null 2>&1; then
        docker-compose ps --services
      else
        docker compose ps --services
      fi | fzf --prompt=' shell > '
  )" || return 0

  [ -z "$svc" ] && return 0

  if command -v docker-compose >/dev/null 2>&1; then
    docker-compose exec "$svc" bash 2>/dev/null || docker-compose exec "$svc" sh
  else
    docker compose exec "$svc" bash 2>/dev/null || docker compose exec "$svc" sh
  fi
}

# Agregar una l√≠ne r√°pida a lista de tareas
todo() {
  local file="$HOME/.todo.cli.txt"

  if [ $# -eq 0 ]; then
    nl -ba "$file" 2>/dev/null || printf '(lista vacia)\n'
    return 0
  fi

  printf '[%s] %s\n' "$(date +'%Y-%m-%d %H:%M')" "$*" >> "$file"
  printf "A√±adido a TODO: %s\n" "$*" >&2
}

# Quien escucha en que puerto
ports() {
  if command -v ss>/dev/null 2>&1; then
    ss -tulpen 2>/dev/null \
    | sed '1,1!s/^/ /' \
    | awk '{print $1, $5, $7, $9}' \
    | column -t 
  elif command -v lsof >/dev/null 2>&1; then
    lsof -nP -iTCP -sTCP:LISTEN
  else
    printf 'Necesito ss o lsof.\n' >&2
    return 1
  fi
}

# Limpia ramas locales ya mergeadas
gclean() {
  _req git || return 1

  if ! git rev-parse --is-inside-work-tree >/dev/null 2>/dev/null; then
    printf 'No est√°s en un repo git.\n' >&2
    return 1
  fi

  local base
  if git show-ref --verify --quiet refs/heads/main; then
    base=main
  elif git show-ref --verify --quiet refs/heads/master; then
    base=master
  else
    base="$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's#.*/##')"
  fi
    
  git fetch --all --prune >/dev/null 2>&1

  local current
  current="$(git rev-parse --abbrev-ref HEAD)"

  local merged 
  merged="$(git branch --merged "$base" \
      | sed 's/^[* ] *//' \
      | grep -v "^$base$" \
      | grep -v "^$current$"
  )"

  if [ -z "$merged" ]; then
    printf 'No hay ramas mergeadas para limpiar.\n' >&2
    return 0
  fi

  printf 'Las siguientes ramas ya est√°n mergeadas en %s:\n' "$base" >&2
  printf '%s\n' "$merged" >&2
  printf '¬øBorrarlas? [y/N] ' >&2
  read -r ans 
  [ "$ans" = "y" ] || return 0

  printf '%s\n' "$merged" | while read -r br; do 
    [ -z "$br" ] && continue
    git branch -d "$br"
  done
}

# Monitoreo rapido de CPU/MEM de procesos
topme() {
  ps -eo pid,ppid,user,%cpu,%mem,etime,cmd --sort=-%cpu \
  | awk 'NR==1 || /php|fpm|nginx|mysql|docker|composer|artisan|symfony/'
}


# "Hazlo otra vez"
r() {
  local tmp last
  tmp="$(mktemp)"

  last="$(HISTTIMEFORMAT= history | sed 's/^ *[0-9]\+ *//' | tail -n 2 | head -n 1)"
  printf '%s\n' "$last" > "$tmp"
  "${EDITOR:-nvim}" "$tmp"
  printf 'Ejecutar?\n' >&2
  read -r ans 
  if [ "$ans" = "y" ]; then
    . "$tmp"
  else
    cat "$tmp"
  fi
  rm -f "$tmp"
}

# A√±ade un temporizador interactivo simple
tt() {
  local start end delta
  start=$(date +%s)
  printf ' Timer iniciado. Pulsa ENTER al terminar...\n' >&2
  read -r _
  end=$(date +%s)
  delta=$(( end - start ))
  printf ' %s segundos (%s min)\n' "$delta" "$(( delta / 60 ))"
}

# Papelera en vez de rm directo 
trash() {
  command -v trash-put >/dev/null 2>&1 || {
    printf 'Necesito trash-put (trash-cli)\n' >&2
    return 1
  }
  trash-put -- "$@"
}


# Watcher de cambios locales en vivo 
watchdiff() {
  _req git || return 1

  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    printf 'No est√°s en un repo git.\n' >&2
    return 1
  fi

  while true; do 
    clear
    local _root _branch
    _root="$(git rev-parse --show-toplevel)"
    _branch="$(got rev-parse --abbrev-ref HEAD)"
    printf " %s (%s)\n" "$_root" "$_branch"
    echo
    git status --short
    echo
    echo "---- cambios no stageados (hasta 200 l√≠neas) -----"
    git diff --color=always | sed -n '1,200p'
    sleep 2
  done
}

# Guarda el stash de trabajo con nombre legible

checkpoint() {
    _req git || return 1

    if ! git rev-parse --is-inside-work-tree >/dev/null 2>/dev/null; then
        printf 'No est√°s en un repo git.\n' >&2
        return 1
    fi

    local msg="${*:-work-in-progress}"
    git add -A
    git stash push -m "$msg"
    printf "‚úî Guardado como checkpoint: %s\n" "$msg" >&2
    git stash list | head -n 5
}

# Commit rapido "Work in progress"
# - despues reescribir con rebase -i  o  git commit --amend
wip() {
    _req git || return 1
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>/dev/null; then
        printf 'No est√°s en un repo git.\n' >&2
        return 1
    fi

    git add -A
    git commit -m "WIP $(date +'%Y-%m-%d %H:%M')" || {
        printf 'Nada que commitear.\n' >&2
        return 0
    }
    printf '‚úî WIP guardado.\n' >&2
}

# Generear commits "fixup!" contra el ultimo commit
fixup() {
    _req git || return 1
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>/dev/null; then
        printf 'No est√°s en un repo git.\n' >&2
        return 1
    fi

    local target msg
    target="$(git rev-parse --verify HEAD)" || return 1
    msg="$(git log -1 --pretty=format:%s)"

    git add -A
    git commit --fixup "$target" || {
        printf 'Nada que fixupear.\n' >&2
        return 0
    }

    printf '‚úî fixup! -> %s\n' "$msg" >&2
    printf 'Para plegar historia luego:\n  git rebase -i --autosquash <base>\n' >&2
}


# Mide cuanto tiempo tarda en ejecutarse un comando
bench() {
    if [ $# -eq 0 ]; then
        printf 'Uso: bench <comando ...>\n' >&2
        return 1
    fi

    local start end delta
    start=$(date +%s%3N)  # ms si tu date lo soporta, GNU date s√≠
    "$@"
    end=$(date +%s%3N)
    delta=$(( end - start ))
    local secs 
    if command -v bc >/dev/null 2>&1; then 
      secs="$(echo "$delta / 1000" | bc -l)"
    else
      secs="$(awk -v d="$delta" 'BEGIN{ printf "%.3f", d/1000 }')"
    fi
    printf "‚è±  %s ms (~%s s)\n" "$delta" "$secs"
}

# ultimos arhivos que hemos tacodo en este repo
recent() {
    _req git fzf bat || return 1

    if ! git rev-parse --is-inside-work-tree >/dev/null 2>/dev/null; then
        printf 'No est√°s en un repo git.\n' >&2
        return 1
    fi

    local file
    file="$(
        git log --name-only --pretty=format: --since='3 days ago' \
        | sed '/^$/d' \
        | sort -u \
        | fzf --prompt='üïë recientes > ' \
              --preview='bat --style=numbers --color=always {} 2>/dev/null | head -500' \
              --preview-window=right,70%
    )" || return 0

    [ -z "$file" ] && return 0

    _edit_at "$file"
}

# repite el ultimo comando fallido
redo() {
    # requiere `fc`, builtin de bash, que edita √∫ltimo comando en $EDITOR
    # y luego lo ejecuta
    local last_status="$?"
    if [ "$last_status" -eq 0 ]; then
        printf 'El √∫ltimo comando NO fall√≥.\n' >&2
        return 1
    fi
    fc -e "${EDITOR:-nvim}"
}

# Cambia entre distintos .env de forma segura
envswap() {
    # uso:
    #   envswap list
    #   envswap use staging
    # asume archivos tipo .env.staging, .env.local, etc.

    local base=".env"
    local cmd="$1"
    local name="$2"

    if [ "$cmd" = "list" ]; then
        ls -1 .env.* 2>/dev/null \
        | sed 's/^\.env\.//' \
        | sort
        return 0
    fi

    if [ "$cmd" = "use" ] && [ -n "$name" ]; then
        local src=".env.$name"
        if [ ! -f "$src" ]; then
            printf 'No existe %s\n' "$src" >&2
            return 1
        fi

        if [ -f "$base" ]; then
            cp "$base" "$base.bak.$(date +%s)"
        fi

        cp "$src" "$base"
        printf '‚úî %s activado -> %s\n' "$src" "$base" >&2
        return 0
    fi

    printf 'Uso:\n' >&2
    printf '  envswap list           # ver entornos disponibles (.env.*)\n' >&2
    printf '  envswap use staging    # copia .env.staging -> .env (guardando backup)\n' >&2
    return 1
}

